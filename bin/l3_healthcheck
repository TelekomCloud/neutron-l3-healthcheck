#
# Copyright (C) 2013 eNovance SAS <licensing@enovance.com>
#
# Author: Sylvain Afchain <sylvain.afchain@enovance.com>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import datetime
import eventlet
import socket

import sqlalchemy as sa

from oslo.config import cfg

from quantum.api.rpc.agentnotifiers import l3_rpc_agent_api as l3_rpc
from quantum.common import constants
from quantum.common import topics
from quantum import context as n_context
from quantum.db import agentschedulers_db
from quantum.db import agents_db
from quantum.db import api as db_api
from quantum.db import db_base_plugin_v2
from quantum.db import l3_db
from quantum.db import model_base
from quantum.openstack.common import log as logging
from quantum.openstack.common import periodic_task
from quantum.openstack.common.rpc import proxy
from quantum.openstack.common import service
from quantum.openstack.common import timeutils
from quantum.scheduler import l3_agent_scheduler

LOG = logging.getLogger(__name__)

HEALTHCHECK_LOCK = "l3-healthcheck"


class L3HealthcheckLock(model_base.BASEV2):
    """Represents a lock."""

    lock_id = sa.Column(sa.String(16), primary_key=True)
    valid_timestamp = sa.Column(sa.DateTime, nullable=False)
    host = sa.Column(sa.String(48), nullable=False)


class L3AgentNotify(proxy.RpcProxy):
    """API for plugin to notify L3 agent."""
    BASE_RPC_API_VERSION = '1.0'

    def __init__(self, topic=topics.L3_AGENT):
        super(L3AgentNotify, self).__init__(
            topic=topic, default_version=self.BASE_RPC_API_VERSION)

    def _notification(self, context, method, router_ids):
        """Notify all the agents that are hosting the routers."""
        self.fanout_cast(
            context, self.make_msg(method,
                                   routers=router_ids),
            topic=topics.L3_AGENT)

    def routers_updated(self, context, router_ids):
        if router_ids:
            self._notification(context, 'routers_updated', router_ids)


class L3HealthcheckAgent(db_base_plugin_v2.QuantumDbPluginV2,
                         l3_agent_scheduler.ChanceScheduler,
                         l3_db.L3_NAT_db_mixin,
                         agentschedulers_db.AgentSchedulerDbMixin):

    def __init__(self, host):
        self.context = n_context.get_admin_context()
        self.l3_notifier = L3AgentNotify()
        self.session = db_api.get_session()
        self.host = host

    def lock(self, context):
        try:
            with self.session.begin(subtransactions=True):
                hc_lock = L3HealthcheckLock(lock_id=HEALTHCHECK_LOCK,
                                            valid_timestamp=timeutils.utcnow(),
                                            host=self.host)
                self.session.add(hc_lock)
        except:
            LOG.warning(_("Unable to get a lock, migration in progress"))
            return False

        return True

    def unlock(self, context):
        with self.session.begin(subtransactions=True):
            query = self.session.query(L3HealthcheckLock)
            hc_lock = query.first()
            if hc_lock:
                self.session.delete(hc_lock)

    def purge_locks(self, context):
        delta = datetime.timedelta(
            seconds=cfg.CONF.L3HEALTHCHECK.lock_validity)
        tm = timeutils.utcnow() - delta
        with self.session.begin(subtransactions=True):
            query = self.session.query(L3HealthcheckLock)
            query = query.filter(L3HealthcheckLock.valid_timestamp < tm)
            hc_lock = query.first()
            if hc_lock:
                self.session.delete(hc_lock)

    def healthcheck(self, context):
        agents = self.get_agents(self.context)
        for agent in agents:
            if (agent['agent_type'] == constants.AGENT_TYPE_L3 and
                    agent['admin_state_up']):

                if agents_db.AgentDbMixin.is_agent_down(
                        agent['heartbeat_timestamp']):
                    LOG.error(_("Start migration of the agent %s"),
                              agent['host'])

                    lck = self.lock(context)
                    if not lck:
                        continue

                    self.update_agent(self.context, agent['id'],
                                      {'agent': {'admin_state_up': False}})

                    routers = self.list_routers_on_l3_agent(self.context,
                                                            agent['id'])

                    router_ids = []
                    for router in routers['routers']:
                        LOG.debug("Reschedule router %s from agent %s",
                                  router['id'], agent['id'])

                        self.schedule(self, self.context, router['id'])
                        LOG.debug("Router %s rescheduled", router['id'])

                        self.remove_router_from_l3_agent(self.context,
                                                         agent['id'],
                                                         router['id'])

                        router_ids.append(router['id'])

                    LOG.debug(_("Notify all l3 agent for router migrations"))
                    self.l3_notifier.routers_updated(self.context,
                                                     router_ids)

                    l3_rpc.L3AgentNotify.agent_updated(self.context,
                                                       True, agent['host'])

                    self.unlock(context)


class L3healthcheckManager(periodic_task.PeriodicTasks):
    def __init__(self, host):
        self.l3_hc_agent = L3HealthcheckAgent(host)

    @periodic_task.periodic_task
    def healcheck(self, context):
        LOG.info("Healthcheck")
        self.l3_hc_agent.healthcheck(context)

    @periodic_task.periodic_task
    def purge_locks(self, context):
        LOG.info("Healthcheck")
        self.l3_hc_agent.purge_locks(context)


class L3healthcheck(service.Service):

    OPTS = [
        cfg.IntOpt(
            'check_interval',
            default=10,
            help='Seconds between periodic check'),
        cfg.IntOpt(
            'lock_validity',
            default=5,
            help='Seconds of the lock validity'),
        cfg.StrOpt(
            'peer_server',
            help='Peer l3healthcheck server')
    ]

    def __init__(self, host):
        super(L3healthcheck, self).__init__()
        self.manager = L3healthcheckManager(host)
        db_api.configure_db()

    def start(self):
        super(L3healthcheck, self).start()
        self.tg.add_timer(
            cfg.CONF.L3HEALTHCHECK.check_interval,
            self.manager.run_periodic_tasks,
            None,
            None
        )


def main():
    LOG.debug("Starting....")
    eventlet.monkey_patch()

    server = L3healthcheck(socket.gethostname())
    service.launch(server).wait()


if __name__ == "__main__":
    product_name = "l3healthcheck"

    cfg.CONF(project=product_name)
    cfg.CONF.register_opts(L3healthcheck.OPTS, "L3HEALTHCHECK")
    logging.setup(product_name)
    main()
